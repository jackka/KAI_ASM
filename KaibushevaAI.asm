Comment &
A1*x1 + A2*x2 + A3*x3 + A4*x4 + A5*x5 = D,
xi - неизвестные положительные целые, Ai и D Рзаданные положительные целые константы
i=1,..,5
ђазмер начальной популЯции N задаЮт пользователь в диапазоне  4<= N<= 10. 
ЌачальнаЯпопулЯциЯ формируетсЯ случайным образом.
Љритерии останова:
1) превышение заданного пользователем количества итераций M;
2) достижение нулевого значениЯ целевой функции.
‚ид селекции  :   cлучайнаЯ схема [4]
‚ид скрещиваниЯ  :   одноточечное [4]
ЊутациЯ   :   изменение случайно выбранного бита;
Љоличество скрещиваемых особей и вероЯтность мутации задаютсЯ пользователем.
’ребованиЯ к программе
программа должна работать в двух режимах:
тестовый
основной
‚ тестовом режиме программа выводит на экран популЯцию решений, получаемую на каждом шаге работы алгоритма. 
‚ основном режиме выводитсЯ только решение, значение функции (невЯзка уравнениЯ, котораЯ в идеале должна обращатьсЯ в ноль) и количество сделанных итераций.
‚се шаги алгоритма (генерациЯ начальной популЯции, селекциЯ, скрещивание, мутациЯ, вычисление целевой функции), должны быть реализованы в виде отдельных процедур.
&

include console.inc 

extern  PopulationGEN@4:near, Random_mid@0:near, Selection@0:near, Skreshiv@0:near, Mutation@0:near, OcenkaPopul@12:near, OutResult@4:near ;внешние процедуры

 

.data
N    DB ?			;размер начальной популЯции в диапазоне  4<= N<= 10
X    DD 50 DUP (?)	;берем только посдений байт, но место резервируем под полный DD
A    DB 5 DUP (?)	;вводит пользователь
D    DD ?			;вводит пользователь
M    DB ?			;количество итераций
K    DB ?			;количество скрещиваемых особей
P    DB ?			;вероЯтность мутации (1/p)

Res  DD 10 DUP (?)	;результаты вычиления уравнений



.code
start:

outstr "введите N в диапазоне 4...10 : "
inintln  [N]

outstr "A1="					;запрос на ввод A1
inintln [A]					
outstr "A2="					;запрос на ввод A2
inintln [A+1]				
outstr "A3="					;запрос на ввод A3
inintln [A+2]				
outstr "A4="					;запрос на ввод A4
inintln [A+3]				
outstr "A5="					;запрос на ввод A5
inintln [A+4]				
 
outstr "введите D : "			;свободный член уравнения 
inintln [D]				

outstr "введите M : "
inintln [M]         
                    
outstr "введите K : "
inintln [K]         
                    
outstr "введите P : "
inintln  [P]


 push offset X
 
 call PopulationGEN@4
  


	mov ecx, 0			
	lea esi, X			
equation_calc:
 
    push offset D		; параметры загружаются в обратном порядке
	push esi			
	push offset A

	call OcenkaPopul@12
	
	nop
	cmp eax,0
	je outresult
	
	outwordln eax
	mov Res[ecx*4], eax
		
	inc ecx
	add esi, 20		; движемся по массиву X с шагом 5( это OcenkaPopul@12 скачет через 5 ) * 4( генератор сл. работает с DD ) 

	cmp cx,10			; от 0 до 9 ключительно
	jne  equation_calc
 
 
 
	jmp lexit
	
outresult:
	push esi
	call OutResult@4

lexit:

newline
pause "press any key to exit"
exit
end start


